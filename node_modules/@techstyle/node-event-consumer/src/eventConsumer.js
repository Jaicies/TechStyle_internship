'use strict';

const {Kafka, logLevel} = require('kafkajs');

const fs = require('fs');

const DEFAULT_CONNECTION_TIMEOUT = 6000;
const DEFAULT_MAX_RETRIES = 3;
const PRODUCTION_ENVIRONMENT = 'production';

/**
 * Event Consumer class
 */
class EventConsumer {
  /**
   * Construct of EventConsumer class
   * @param {array} brokerList - The brokerList as an array
   * @param {string} clientId - The clientId.
   * @param {string} environment - The environment.
   * @param {string} kafkaCAFile - Path to the Kafka CA File
   * @param {number} kafkaConnectionTimeout - Kafka connection timeout. Default is 3000ms
   * @param {number} maxRetryTime - Max try time in ms. Default is 3000ms
   * @param {number} maxRetries - Max number of retries. Default is 3
   * @param {number} defaultTimeout - Default timeout. Default is 3000ms
   */
  constructor(
    brokerList,
    clientId,
    environment,
    kafkaCAFile,
    kafkaConnectionTimeout = DEFAULT_CONNECTION_TIMEOUT,
    maxRetryTime = DEFAULT_CONNECTION_TIMEOUT,
    maxRetries = DEFAULT_MAX_RETRIES,
    defaultTimeout = DEFAULT_CONNECTION_TIMEOUT,
  ) {
    this.brokerList = brokerList;
    this.clientId = clientId;
    this.environment = environment;

    this.KAFKA_CA_FILE = kafkaCAFile;
    this.KAFKA_CONNECTION_TIMEOUT = kafkaConnectionTimeout;
    this.KAFKA_MAX_RETRY_TIME = maxRetryTime;
    this.KAFKA_MAX_RETRIES = maxRetries;

    this.CONSUMER_DEFAULT_TIMEOUT = defaultTimeout;
  }

  /**
   * Subscribe to a topic
   * @param {string} groupId - Unique identifier for the consumer group
   * @param {string} topic - The topic to subscribe to
   * @param {function} consumerCallback - The function to use for consuming the message
   * @param {boolean} fromBeginning - Start from the beginning? default = false
   */
  async subscribeToEachMessage(groupId, topic, consumerCallback, fromBeginning = false) {
    // validation
    if (!groupId) {
      throw new Error('Missing required parameter (groupId) for event consumer');
    }

    if (!topic) {
      throw new Error('Missing required parameter (topic) for event consumer');
    }

    if (!consumerCallback) {
      throw new Error('Missing required parameter (consumerCallback) for event consumer');
    }

    const consumer = await this.getConsumer(groupId);

    await consumer.subscribe({
      topic,
      fromBeginning,
    });

    await consumer.run({
      autoCommit: false,
      eachMessage: consumerCallback,
    });
  }

  /**
   * Either get this.consumer or instantiate
   * @param {string} groupId - Unique identifier for the consumer group
   */
  async getConsumer(groupId) {
    if (!this.consumer || this.consumer.groupId !== groupId) {
      const client = await this.getClient();
      this.consumer = client.consumer({groupId});
      await this.consumer.connect();
    }

    return this.consumer;
  }

  /**
   * Either get this.client or instantiate
   */
  async getClient() {
    if (!this.client) {
      this.client = await this.createClient();
    }

    return this.client;
  }

  /**
   * Create the streaming client
   */
  async createClient() {
    // validation
    if (!this.clientId) {
      throw new Error('Missing required parameter (clientId) for event consumer');
    }

    if (!this.brokerList) {
      throw new Error('Missing required parameter (brokerList) for event consumer');
    }

    if (!this.environment) {
      throw new Error('Missing required parameter (environment) for event consumer');
    }

    if (!this.KAFKA_CA_FILE) {
      throw new Error('Missing required parameter (KAFKA_CA_FILE) for event consumer');
    }

    this.client = await new Kafka({
      clientId: this.clientId,
      brokers: this.brokerList,
      logLevel: this.environment === PRODUCTION_ENVIRONMENT ? logLevel.ERROR : logLevel.DEBUG,
      ssl: {
        rejectUnauthorized: false,
        ca: [fs.readFileSync(this.KAFKA_CA_FILE, 'utf-8')],
      },
      retries: this.KAFKA_MAX_RETRIES,
      maxRetryTime: this.KAFKA_MAX_RETRY_TIME,
      connectionTimeout: this.KAFKA_CONNECTION_TIMEOUT,
    });

    return this.client;
  }
}

module.exports = EventConsumer;
